Hi guys and welcome back. In this video and the next, I wanted to talk with you about Mutability in Python and how it can affect your programmes. It's a very important part of Python to know about, so let's dive right in. Here we've got a list, and we have given it the name a. Then we have created the name b and made it equal to the value of name a. This way of saying things that I'm saying right now is very important because you'll see quite often, people say, "You've created a list called a, "and then you created a list called b. "That's not correct in Python." a and b are names. The value is this list. So if you print the ID of a, and then you print the ID of b, and in CPython, the Python version that I'm using and that most of you will be using, the ID function, when you give it any object such as this list, will give you back the location in memory of them, so by running this code here, you can see that the output is exactly the same. That means that a and b are names for the same object, the same thing. Indeed you can see that being the case if you just do a.append 35, and then you print a and print b. If you do that, you'll see that both a and b change when you modified a. You appended 35 to a, and both a and b ended up with 35. That means that both a and b are references to the same object, this one list. However, if you did b equals another list, then this would be different now. You have one list that has a 35 in it, and the other one that does not. In Python, this is the syntax for creating an empty list, so both of these are created separately, and they are stored separately. Once again, going to the ID, you'll see that these are indeed now different numbers. So let me lay that, and you can see that you get two different numbers. You can compare the last couple digits there. So the fact that you can change a list after you have created it means that a list is mutable. You can mutate it; that's the same thing as changing. Some values can't be changed, and they are immutable values. In Python, all things are mutable because everything's an object unless there are specifically no ways of changing the properties of the object itself. Let's go into an example. For example, if you define these to be tuples, there are actually no ways of adding or removing an element from a tuple. If you do a.append, you're gonna get an error saying that tuples don't have an append method in them. If you do a equal a plus something, you're going to create a new tuple. You're not going to be modifying that one. So tuples are immutable. Let's take a look at another example. Imagine you have two numbers such as 8597 and 8597. These are the same value, 8597 in both cases, and you can see that the IDs are the same. So why did this differ in lists when you created two empty lists, but not in integers? Python has this optimization where when an integer is created, then it won't recreate it if another one identical to it is used. So here Python knows that 8597 has already been created, so it doesn't create a new one. Integers are also immutable; you can't change them. New Python developers often believe that if you do something like 8598, now b should change as well because you have changed this number here, but that is not at all what's happened. This value was created first, and a is a name for that value. The name assignment happens with the equals sign, and here, you have created the value 8598, and you have given it the name a. However, b is still a name for 8597. That hasn't changed at all. However, if you do print these IDs, you can see that that's all correct, and they are now different. They are identical at the start, and then they differ afterwards. As I said earlier, most things in Python are mutable except for tuples, strings, integers, floats, and booleans. I believe that's most of the immutable ones. All the rest are mutable, and if you want to create an immutable class and immutable objects, just don't add any methods in them that can change the object's properties. For example, if you have a book object and you want it immutable, don't allow anybody to change the name property of that book. One more example for beginner Python developers is that if you create a string called hello and give it the name a, and then make b and give it the same value as a's value, then these will be the same. If you do plus equal, that is the same thing as doing equal a plus world, so you are reassigning the name a into this new string, but b will still be hello, so this will change the name a. It won't change the string hello. So that's something important to remember. Immutable types like strings, you can't change them. It's physically not possible in Python to change them, so whenever you are assigning, you're always going to be changing the existing name and not the value, and the same thing for tuples, integers, floats, and booleans. That's it for this video. I wanted to tell you a bit about mutability in Python. In the next one, we're going to learn why it's important to know about it. So stick with me, and I'll see you in the next video.