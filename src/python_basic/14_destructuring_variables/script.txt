Hi guys, and welcome back! In this video, we're going to learn about destructuring variables, which is something we looked at in the previous video, in the for-loop, but now we're going to explain how it works. Normally in Python when you assign a variable, you can do something like x equal five, say. But, you can also do x equal five comma 11. And, this, here is a tuple. We've learned about these in the past. But, what a lot of people don't know, is that the brackets are not necessary, the brackets are only necessary when Python might be confused as to whether you wanna create a tuple, or these are values in another collection. So if you have a tuple like this one, you can actually remove the brackets. But, if you wanted to create a list with a tuple inside it, then, you would need the brackets. Because, if you don't put the brackets in, you'll actually end with a list with two values, not a list with a tuple inside it. So, the brackets are only needed when you want to explicitly say, I want a tuple here, I don't want Python to treat these as two separate values. But most of the time, the brackets are not necessary, so you can leave it as this. Now, regarding destructuring variables, this tuple here can be destructured or decomposed, or split-out into two variables if you want. X, comma, y, and Python is smart enough to assign x to five and y to 11. It's just a shorthand, instead of defining two variables separately. The extra benefit that we get from being able to do something like this is that if you have another tuple, which is five and 11, you can then actually say something like this, x comma y equal t. And then, we can print x and y. So if we run this, you'll see that you get five and 11 as the two separate variables. So, Python was smart enough to say, okay, t is a tuple, and you're asking me to assign this tuple to two variables, what I'm gonna do is I'm gonna split it out into it's components. So this is what destructuring really means. In the last video, we had some code like this one, where we have a dictionary of strings to integers, and then we iterated over student attendance dot items. Now, I'm going to print the list of that, which is going to take this stuff here, turn it into a list, and print it out. So, let me do that, and not print that, and show you what happens. Notice that what you get back is a list of tuples. So, if you iterate over a list of tuples, that means that, by doing something like this, what you are getting is three different tuples. Let me show you what happens if I say that, and then I print t there, and then I common that out. You can see that t is first a tuple of Rolf and 96, then a tuple of Bob and 80, and then a tuple of Anne and 100. So, instead of t, we can access its components because we can destructure this into two separate variables, and that's what we were doing earlier on, when we destructured the tuple into student, and attendance. Student would be Rolf, and attendance would be 96. And then the next time you go through the loop, you'd get the next tuple, and that would be destructured into its two components, again, and so on. So that, is why this works. Hopefully that makes sense, that is destructuring in use here in a for-loop, and you're gonna see it quite a lot when you do something like items, or when you use something like the enumerate function that I know we haven't spoke about yet, it is quite prevalent in Python. I'm going to link a blog post on destructuring variables that you can read as well if you'd like. Let's take a look at another example, here we have a list of people where instead of a dictionary, each person has a tuple with three values. Their name, their age, and their profession. Because we've got a tuple of three values, we can do for name, age, and profession in people, and that is going to, once again, iterate through each of the tuples, and for each one, destructure it into its three separate components. So here, we could print NA string describing this person, just like that. Notice that if any one of your tuples is missing a value, you're going to encounter some problems. It says, value error, not enough values to unpack. So you tried to access three values of this tuple, but there weren't three values, profession was missing, so you got this error. So this is something you have to be careful with, when you're doing this destructuring or unpacking. Notice that the alternative to doing this is to iterate over each tuple, and print out each thing, using indices. So, person zero would be the name, person one would be the age, and person two would be the profession, if you don't destructure the variable here. So, this is clearly much less readable, it's not as obvious what's going on, so destructuring these things does help your code look a bit nicer. Let's say you got a single tuple, and you want to extract a person's name and profession, but you don't care for the age. In Python, variables can contain and even start with an underscore, and that is frequently what's used as a variable when you want to ignore one. So, you can say name underscore profession equal person, and what this is going to do is it's going to create three variables, name, underscore, and profession, and Bob will become name, 42 will become underscore, and mechanic will become profession. But, the underscore on its own is so bad a variable name, that nobody would wanna use it, unless it was not meant to be used. So that is what the Python community has decided, that if you use an underscore variable on its own, that is because you don't care about this variable, this variable is meant to be ignored. So then, it's just as good to print name and profession out, if you wanted to just print the person's details out. Let's say you've got a list of five elements, one, two, three, four, and five, and you wanted to separate this into two lists. The first element, and all the other elements. Well, you can do head comma star tail, and that is the syntax for collecting. So, what you are doing, is you are collecting all of the destructured values into this variable. All of the values that don't match any of the other destructured values, which in this case you've got the head. So the first value in here will become the head, and then this syntax here will collect the other values, and will put them all into tail. So if you print head, and you print tail, then you'll see what happens is you get one, as the first value, and two, three, four, and five as the second value. Notice that you only need to do this when you want to put all the values into one place, you never need to use it again like that, you don't have to do that. Instead of that, you can move this of course, and put the star at the front if you like, and then this is going to collect as many values as possible, but leaving room for the tail, which is gonna be the last one. So, head will be one, two, three, four, and tail will be five, just like that. The asterisk can also be used here, we're not going to learn about that just now, we're going to learn about it in a few videos times, it's a little bit more advanced, so I wanna get into some of the other topics before we talk about that one. So, please do bear with me, and know that that will work if you do that, and it will print out something slightly different, and not printing the list anymore, now which brings you the separate values, and that is valid Python and you will use it quite a lot as you programme in Python, but again we're going to learn about it in a later video. So, please, bear with me, I hope this video's been useful, and I'll see you in the next one.